{
    "rec_point": "os.path.isabs(instance_path)",
    "candidate_apis": [
        "_abspath_fallback",
        "_get_bothseps",
        "_getfinalpathname",
        "_getfinalpathname_nonstrict",
        "_getfullpathname",
        "_getvolumepathname",
        "_nt_readlink",
        "_readlink_deep",
        "abspath",
        "altsep",
        "basename",
        "commonpath",
        "commonprefix",
        "curdir",
        "defpath",
        "devnull",
        "dirname",
        "exists",
        "expanduser",
        "expandvars",
        "extsep",
        "genericpath",
        "getatime",
        "getctime",
        "getmtime",
        "getsize",
        "isabs",
        "isdir",
        "isfile",
        "islink",
        "ismount",
        "join",
        "lexists",
        "normcase",
        "normpath",
        "os",
        "pardir",
        "pathsep",
        "realpath",
        "relpath",
        "samefile",
        "sameopenfile",
        "samestat",
        "sep",
        "split",
        "splitdrive",
        "splitext",
        "stat",
        "supports_unicode_filenames",
        "sys"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.[API_POINT]:\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.unknown_api():\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        reveal_type(os.path)",
    "data_flow": "os-->path-->unknown_api"
}{
    "rec_point": "os.path.splitext(os.path.basename(fn))",
    "candidate_apis": [
        "_abspath_fallback",
        "_get_bothseps",
        "_getfinalpathname",
        "_getfinalpathname_nonstrict",
        "_getfullpathname",
        "_getvolumepathname",
        "_nt_readlink",
        "_readlink_deep",
        "abspath",
        "altsep",
        "basename",
        "commonpath",
        "commonprefix",
        "curdir",
        "defpath",
        "devnull",
        "dirname",
        "exists",
        "expanduser",
        "expandvars",
        "extsep",
        "genericpath",
        "getatime",
        "getctime",
        "getmtime",
        "getsize",
        "isabs",
        "isdir",
        "isfile",
        "islink",
        "ismount",
        "join",
        "lexists",
        "normcase",
        "normpath",
        "os",
        "pardir",
        "pathsep",
        "realpath",
        "relpath",
        "samefile",
        "sameopenfile",
        "samestat",
        "sep",
        "split",
        "splitdrive",
        "splitext",
        "stat",
        "supports_unicode_filenames",
        "sys"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.[API_POINT][0]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.unknown_api()[0]\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            reveal_type(os.path)",
    "data_flow": "os-->path-->unknown_api"
}{
    "rec_point": "os.path.join(package_path, \"instance\")",
    "candidate_apis": [
        "_abspath_fallback",
        "_get_bothseps",
        "_getfinalpathname",
        "_getfinalpathname_nonstrict",
        "_getfullpathname",
        "_getvolumepathname",
        "_nt_readlink",
        "_readlink_deep",
        "abspath",
        "altsep",
        "basename",
        "commonpath",
        "commonprefix",
        "curdir",
        "defpath",
        "devnull",
        "dirname",
        "exists",
        "expanduser",
        "expandvars",
        "extsep",
        "genericpath",
        "getatime",
        "getctime",
        "getmtime",
        "getsize",
        "isabs",
        "isdir",
        "isfile",
        "islink",
        "ismount",
        "join",
        "lexists",
        "normcase",
        "normpath",
        "os",
        "pardir",
        "pathsep",
        "realpath",
        "relpath",
        "samefile",
        "sameopenfile",
        "samestat",
        "sep",
        "split",
        "splitdrive",
        "splitext",
        "stat",
        "supports_unicode_filenames",
        "sys"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            reveal_type(os.path)",
    "data_flow": "os-->path-->unknown_api"
}{
    "rec_point": "sys.exc_info()",
    "candidate_apis": [
        "_base_executable",
        "_clear_type_cache",
        "_current_frames",
        "_debugmallocstats",
        "_enablelegacywindowsfsencoding",
        "_framework",
        "_getframe",
        "_git",
        "_home",
        "_xoptions",
        "addaudithook",
        "api_version",
        "argv",
        "audit",
        "base_exec_prefix",
        "base_prefix",
        "breakpointhook",
        "builtin_module_names",
        "byteorder",
        "call_tracing",
        "callstats",
        "copyright",
        "displayhook",
        "dllhandle",
        "dont_write_bytecode",
        "exc_info",
        "excepthook",
        "exec_prefix",
        "executable",
        "exit",
        "flags",
        "float_info",
        "float_repr_style",
        "get_asyncgen_hooks",
        "get_coroutine_origin_tracking_depth",
        "getallocatedblocks",
        "getcheckinterval",
        "getdefaultencoding",
        "getfilesystemencodeerrors",
        "getfilesystemencoding",
        "getprofile",
        "getrecursionlimit",
        "getrefcount",
        "getsizeof",
        "getswitchinterval",
        "gettrace",
        "getwindowsversion",
        "hash_info",
        "hexversion",
        "implementation",
        "int_info",
        "intern",
        "is_finalizing",
        "maxsize",
        "maxunicode",
        "meta_path",
        "modules",
        "path",
        "path_hooks",
        "path_importer_cache",
        "platform",
        "prefix",
        "pycache_prefix",
        "set_asyncgen_hooks",
        "set_coroutine_origin_tracking_depth",
        "setcheckinterval",
        "setprofile",
        "setrecursionlimit",
        "setswitchinterval",
        "settrace",
        "stderr",
        "stdin",
        "stdout",
        "thread_info",
        "unraisablehook",
        "version",
        "version_info",
        "warnoptions",
        "winver"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        exc_info = sys.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        exc_info = sys.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        reveal_type(sys)",
    "data_flow": "sys-->unknown_api-->exc_info"
}{
    "rec_point": "self.preprocess_request()",
    "candidate_apis": [
        "show_config",
        "cli",
        "lseek",
        "rsplit",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "bitwise_and",
        "automatically_set_content_length",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "dup",
        "sorted",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            reveal_type(self)\n        except Exception:\n        \tpass",
    "data_flow": "self-->unknown_api-->rv"
}{
    "rec_point": "self.dispatch_request()",
    "candidate_apis": [
        "show_config",
        "cli",
        "lseek",
        "rsplit",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "bitwise_and",
        "automatically_set_content_length",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "dup",
        "sorted",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n                rv = self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n                rv = self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n                reveal_type(self)\n        except Exception:\n        \tpass",
    "data_flow": "self-->unknown_api-->rv"
}{
    "rec_point": "self.make_response(rv)",
    "candidate_apis": [
        "show_config",
        "cli",
        "rsplit",
        "lseek",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "automatically_set_content_length",
        "bitwise_and",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "sorted",
        "dup",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "handle_user_exception",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        response = self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        response = self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        reveal_type(self)",
    "data_flow": "self-->unknown_api-->response"
}{
    "rec_point": "self.process_response(response)",
    "candidate_apis": [
        "show_config",
        "cli",
        "rsplit",
        "lseek",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "automatically_set_content_length",
        "bitwise_and",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "sorted",
        "dup",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "handle_user_exception",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            response = self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            response = self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            reveal_type(self)\n        except Exception:\n        \tpass",
    "data_flow": "self-->unknown_api-->response"
}{
    "rec_point": "self.request_context(builder.get_environ())",
    "candidate_apis": [
        "show_config",
        "cli",
        "rsplit",
        "lseek",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "automatically_set_content_length",
        "bitwise_and",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "response_class",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "sorted",
        "dup",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "allowed_methods",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "handle_user_exception",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n            return self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n            return self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n            reveal_type(self)\n        except Exception:\n        \tpass",
    "data_flow": "self-->unknown_api"
}{
    "rec_point": "self.handle_exception(e)",
    "candidate_apis": [
        "show_config",
        "cli",
        "lseek",
        "rsplit",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "bitwise_and",
        "automatically_set_content_length",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "response_class",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "full_dispatch_request",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "dup",
        "sorted",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "allowed_methods",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "handle_user_exception",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                reveal_type(self)\n        except Exception:\n        \tpass",
    "data_flow": "self-->unknown_api-->response"
}{
    "rec_point": "self.wsgi_app(environ, start_response)",
    "candidate_apis": [
        "show_config",
        "cli",
        "rsplit",
        "lseek",
        "ceil",
        "seconds",
        "license",
        "total_seconds",
        "access_control_allow_origin",
        "automatically_set_content_length",
        "bitwise_and",
        "spawnve",
        "_getframe",
        "unraisablehook",
        "sctypeNA",
        "rename",
        "_AddedDllDirectory",
        "fliplr",
        "compare_chararrays",
        "pi",
        "finalize_request",
        "memmap",
        "arctan",
        "access_control_allow_headers",
        "make_config",
        "access_control_max_age",
        "accept_mimetypes",
        "hello_user",
        "triu_indices",
        "test_request_context",
        "update_template_context",
        "int8",
        "set_numeric_ops",
        "ldexp",
        "ufunc",
        "promote_types",
        "mimetype",
        "bind",
        "uint0",
        "_iter_loaders",
        "arctanh",
        "deg2rad",
        "from_bytes",
        "timeline",
        "days",
        "dot",
        "unicode_",
        "nanargmin",
        "unicode",
        "nanmedian",
        "info",
        "_compile_builder",
        "execv",
        "dont_write_bytecode",
        "asfortranarray",
        "longfloat",
        "iscomplex",
        "_checkSeekable",
        "cdouble",
        "description",
        "cumsum",
        "viewitems",
        "allclose",
        "setdefault",
        "s_",
        "array_split",
        "get",
        "mafromtxt",
        "add_extension",
        "ones_like",
        "defpath",
        "setrecursionlimit",
        "init_builtin",
        "max_cookie_size",
        "bincount",
        "getallocatedblocks",
        "divide",
        "bool8",
        "request_shutdown",
        "geterr",
        "audit",
        "_cleanup_receiver",
        "iterkeys",
        "supports_bytes_environ",
        "pardir",
        "system",
        "rec",
        "stream",
        "minimum",
        "argsort",
        "call_test",
        "amin",
        "add_message",
        "not_equal",
        "_clear_state",
        "flags",
        "diagonal",
        "ndenumerate",
        "array_equiv",
        "numarray",
        "ogrid",
        "routes_command",
        "content_type",
        "settrace",
        "obj2sctype",
        "zeros_like",
        "_weak_senders",
        "rfind",
        "logical_not",
        "array_repr",
        "pv",
        "arcsinh",
        "_tokenize",
        "float",
        "blueprint",
        "select_template",
        "_current_frames",
        "uint16",
        "_get_file_stream",
        "common_type",
        "seterrobj",
        "getattr",
        "trim_zeros",
        "popitem",
        "nonzero",
        "complex",
        "route",
        "flipud",
        "get_app_iter",
        "percentile",
        "getsizeof",
        "setprofile",
        "identity",
        "reload",
        "input",
        "frexp",
        "cov",
        "polymul",
        "issubsctype",
        "re",
        "inexact",
        "translate",
        "reshape",
        "less_equal",
        "preprocess_request",
        "getpid",
        "decode",
        "intp",
        "array",
        "strerror",
        "character",
        "atleast_2d",
        "_get_source_explained",
        "excepthook",
        "date",
        "spawnle",
        "moveaxis",
        "encoding_errors",
        "bitwise_or",
        "polysub",
        "searchsorted",
        "get_response",
        "get_namespace",
        "deleter",
        "infty",
        "response_class",
        "addaudithook",
        "packbits",
        "code",
        "clongfloat",
        "dtype",
        "setswitchinterval",
        "rollaxis",
        "pickle_based",
        "triu_indices_from",
        "handle_exception",
        "items",
        "broadcast_arrays",
        "save_session",
        "exec_prefix",
        "unfollow_user",
        "stat",
        "gcd",
        "spawnv",
        "float32",
        "int",
        "attrgetter",
        "platform",
        "connect",
        "ssl",
        "renames",
        "trapz",
        "where",
        "row_stack",
        "istitle",
        "receiver_disconnected",
        "add_template_filter",
        "load",
        "add_docstring",
        "close",
        "if_none_match",
        "maxsize",
        "use_hugepage",
        "apply_over_axes",
        "rmdir",
        "prepare_import",
        "cache_control",
        "setattr",
        "bartlett",
        "os",
        "if_match",
        "casefold",
        "fromfile",
        "detach",
        "supports_dir_fd",
        "disp",
        "exp",
        "blackman",
        "lexer",
        "query_string",
        "int_",
        "splitlines",
        "arccos",
        "uuid",
        "getcwd",
        "irr",
        "keys",
        "isprintable",
        "listdir",
        "generic",
        "denominator-getter",
        "_load_arg_defaults",
        "oct",
        "_parse",
        "index_exp",
        "datetime_as_string",
        "mask_indices",
        "preprocess",
        "getbufsize",
        "matrix",
        "indices",
        "as_integer_ratio",
        "binary_repr",
        "winver",
        "get_version",
        "isinstance",
        "execlpe",
        "exec_builtin",
        "_base_executable",
        "delete",
        "is_integer",
        "array2string",
        "execle",
        "reciprocal",
        "current_app",
        "isclose",
        "complex64",
        "referrer",
        "dump",
        "reverse",
        "expires",
        "files",
        "_parse_content_type",
        "pmt",
        "format_float_positional",
        "isfinite",
        "degrees",
        "args",
        "isnat",
        "age",
        "find_best_app",
        "popen",
        "get_empty_kwargs",
        "object",
        "rstrip",
        "nansum",
        "join_path",
        "content_md5",
        "sin",
        "encode",
        "detect_encoding",
        "user_timeline",
        "iterable",
        "bitwise_xor",
        "get_description",
        "polyder",
        "_disconnect",
        "waitpid",
        "arccosh",
        "complex128",
        "vander",
        "isidentifier",
        "call_filter",
        "chmod",
        "asmatrix",
        "get_wsgi_response",
        "maketrans",
        "build_compare_key",
        "intersection_update",
        "exp2",
        "locals",
        "discard",
        "require",
        "retry_after",
        "find",
        "open",
        "_exists",
        "cmp",
        "ubyte",
        "_cleanup_sender",
        "getargspec",
        "uintc",
        "void",
        "integer",
        "symmetric_difference",
        "api_version",
        "get_headers",
        "uint",
        "poly",
        "abort",
        "errorhandler",
        "datetime_data",
        "pathsep",
        "expandtabs",
        "sqrt",
        "headers",
        "chr",
        "sctype2char",
        "trap_http_exception",
        "int0",
        "name",
        "nanmin",
        "uintp",
        "title",
        "tril_indices_from",
        "_mat",
        "sinh",
        "before_request",
        "repr",
        "difference",
        "exec",
        "viewkeys",
        "set_coroutine_origin_tracking_depth",
        "access_control_allow_methods",
        "cfloat",
        "round_",
        "remote_user",
        "serializer",
        "_get_func_code",
        "ascontiguousarray",
        "version",
        "follow_user",
        "view_args",
        "can_cast",
        "may_share_memory",
        "displayhook",
        "std",
        "count",
        "remote_addr",
        "isdigit",
        "_load_form_data",
        "roll",
        "isdisjoint",
        "overlayed",
        "int64",
        "_encode_query_vars",
        "is_streamed",
        "has_receivers_for",
        "ediff1d",
        "get_env",
        "json_module",
        "closed",
        "interp",
        "ptp",
        "modf",
        "print_function",
        "create_builtin",
        "base_url",
        "maxunicode",
        "isatty",
        "sum",
        "sort",
        "url_rule",
        "clip",
        "session_class",
        "negative",
        "bind_to_environ",
        "query_db",
        "supports_follow_symlinks",
        "putmask",
        "meta_path",
        "is_finalizing",
        "force_type",
        "access_control_expose_headers",
        "request",
        "json",
        "size",
        "hypot",
        "ma",
        "record",
        "trusted_hosts",
        "_dump_arg_defaults",
        "times_result",
        "block",
        "sctypeDict",
        "_UFUNC_API",
        "complexfloating",
        "make_conditional",
        "fill_diagonal",
        "tile",
        "readlink",
        "asfarray",
        "execl",
        "nanargmax",
        "log10",
        "around",
        "content_range",
        "newaxis",
        "itervalues",
        "matmul",
        "get_etag",
        "bit_length",
        "eye",
        "getcwdb",
        "recfromtxt",
        "timedelta64",
        "application",
        "get_flashed_messages",
        "lookfor",
        "histogram2d",
        "accept_charsets",
        "add_template_global",
        "amax",
        "stack",
        "polynomial",
        "rpartition",
        "quantile",
        "url",
        "float_info",
        "implementation",
        "flash",
        "want_form_data_parsed",
        "coerce",
        "max",
        "safe_eval",
        "diag_indices_from",
        "put",
        "stdin",
        "fileno",
        "executable",
        "subtract",
        "loadtxt",
        "full_dispatch_request",
        "credits",
        "getrecursionlimit",
        "mod",
        "_wrap_reader_for_text",
        "tri",
        "strip",
        "unichr",
        "template_class",
        "mirr",
        "logspace",
        "npv",
        "_home",
        "_slash_escape",
        "asanyarray",
        "codecs",
        "ctypeslib",
        "getter",
        "complex_",
        "nan_to_num",
        "get_user_id",
        "connect_via",
        "getrefcount",
        "create_jinja_environment",
        "base_prefix",
        "list_templates",
        "max_forwards",
        "version_option",
        "get_asyncgen_hooks",
        "lock_class",
        "longlong",
        "extract",
        "maximum",
        "fspath",
        "update_wrapper",
        "intern",
        "_framework",
        "ravel",
        "testing",
        "should_ignore_error",
        "sign",
        "issubclass_",
        "apply_along_axis",
        "_get_stream_for_parsing",
        "byteorder",
        "breakpoint",
        "is_run_once",
        "argv",
        "deprecate_with_doc",
        "eval",
        "compress",
        "iter_extensions",
        "connect_db",
        "isalpha",
        "apply",
        "seterrcall",
        "_enablelegacywindowsfsencoding",
        "make_null_session",
        "full_path",
        "seekable",
        "shell_command",
        "str",
        "isascii",
        "spawnl",
        "iter",
        "line_buffering",
        "float_power",
        "curdir",
        "radians",
        "flush",
        "min",
        "_by_sender",
        "getvalue",
        "log_exception",
        "nanprod",
        "calculate_content_length",
        "diagflat",
        "decorator",
        "is_null_session",
        "from_object",
        "fix",
        "builtin_module_names",
        "sctypes",
        "longdouble",
        "access",
        "readable",
        "with_traceback",
        "dispatch_request",
        "bytes0",
        "msort",
        "sometrue",
        "iter_encoded",
        "setter",
        "expm1",
        "_description",
        "path_importer_cache",
        "content_location",
        "isnan",
        "getwindowsversion",
        "is_json",
        "add_dll_directory",
        "content_length",
        "trace",
        "from_app",
        "from_string",
        "argwhere",
        "www_authenticate",
        "string_",
        "signbit",
        "context_class",
        "floor",
        "help",
        "get_exec_path",
        "_pytesttester",
        "wrap",
        "var",
        "make_sequence",
        "from_values",
        "cos",
        "cbrt",
        "makedirs",
        "full_like",
        "tril_indices",
        "who",
        "signedinteger",
        "values",
        "get_terminal_size",
        "connected_to",
        "add_etag",
        "round",
        "product",
        "lower",
        "receivers_for",
        "_by_receiver",
        "supports_fd",
        "get_handle_inheritable",
        "closerange",
        "argpartition",
        "allow",
        "matrixlib",
        "index",
        "iinfo",
        "busday_count",
        "float16",
        "fabs",
        "receiver_connected",
        "_compile",
        "run",
        "_get_data_for_json",
        "call_tracing",
        "is_multithread",
        "numerator-getter",
        "list_storage_class",
        "histogramdd",
        "savetxt",
        "sinc",
        "partition",
        "singlecomplex",
        "callstats",
        "form_data_parser_class",
        "sort_complex",
        "unravel_index",
        "from_envvar",
        "getppid",
        "with_appcontext",
        "from_mapping",
        "nper",
        "argmin",
        "tracemalloc_domain",
        "typeDict",
        "form",
        "meshgrid",
        "c_",
        "disable_data_descriptor",
        "choose",
        "routing_exception",
        "path",
        "sorted",
        "dup",
        "writable",
        "frombuffer",
        "correlate",
        "filter",
        "join",
        "einsum_path",
        "chdir",
        "isrealobj",
        "tan",
        "freeze",
        "get_coroutine_origin_tracking_depth",
        "version_info",
        "stat_result",
        "getdefaultencoding",
        "ndindex",
        "_exit",
        "getenv",
        "key_derivation",
        "median",
        "url_root",
        "lib",
        "suggested",
        "bool_",
        "typename",
        "swapaxes",
        "remove",
        "stderr",
        "reduce",
        "make_globals",
        "_generate",
        "has_source_access",
        "_get_source_fast",
        "csingle",
        "nested_iters",
        "zfill",
        "ushort",
        "dup2",
        "cross",
        "environ",
        "_wrap_close",
        "vary",
        "cast",
        "result_type",
        "upper",
        "user_agent",
        "getcheckinterval",
        "divmod",
        "hsplit",
        "union1d",
        "login",
        "e",
        "insert",
        "inspect",
        "recarray",
        "getlogin",
        "ndarray",
        "suitable_for",
        "readlines",
        "vdot",
        "map",
        "pass_script_info",
        "busday_offset",
        "access_control_allow_credentials",
        "busdaycalendar",
        "flatiter",
        "closest_rule",
        "greater_equal",
        "place",
        "execlp",
        "resize",
        "writelines",
        "tojson_filter",
        "get_signing_serializer",
        "devnull",
        "print",
        "_checkReadable",
        "tag",
        "iteritems",
        "issubset",
        "jinja_environment",
        "histogram_bin_edges",
        "_xoptions",
        "outer",
        "bmat",
        "to_bytes",
        "bitwise_not",
        "uint64",
        "_fspath",
        "get_source",
        "source",
        "kill",
        "take",
        "dir",
        "isbuiltin",
        "sep",
        "send",
        "authorization",
        "get_cookie_domain",
        "cosh",
        "_checkWritable",
        "float_repr_style",
        "equal",
        "rate",
        "_process_range_request",
        "broadcast_to",
        "status",
        "r_",
        "getfilesystemencodeerrors",
        "gradient",
        "extsep",
        "isfortran",
        "bool",
        "max_content_length",
        "tanh",
        "is_sequence",
        "errors",
        "atleast_3d",
        "match_compare_key",
        "rindex",
        "triu",
        "try_trigger_before_first_request_functions",
        "build",
        "reraise",
        "single",
        "longcomplex",
        "invert",
        "warnoptions",
        "open_resource",
        "float64",
        "sandboxed",
        "linesep",
        "_clear_type_cache",
        "null_session_class",
        "autocorrect_location_header",
        "execvpe",
        "get_debug_flag",
        "dataclasses",
        "mkdir",
        "read",
        "seek",
        "_ensure_sequence",
        "zeros",
        "walk",
        "ix_",
        "_get_exports_list",
        "symlink",
        "status_code",
        "nanstd",
        "method",
        "getprofile",
        "printoptions",
        "set_data",
        "mat",
        "utime",
        "init_db",
        "typeNA",
        "_check_methods",
        "capitalize",
        "lcm",
        "getfilesystemencoding",
        "vectorize",
        "accept_encodings",
        "content_encoding",
        "_cleanup_bookkeeping",
        "delattr",
        "umask",
        "default_status",
        "set_etag",
        "right_shift",
        "nanquantile",
        "dotenv",
        "vars",
        "float_",
        "newlines",
        "flatnonzero",
        "unwrap",
        "format",
        "get_body",
        "fmod",
        "uint32",
        "lstat",
        "angle",
        "column_stack",
        "ravel_multi_index",
        "imag",
        "swapcase",
        "setcheckinterval",
        "copy",
        "register",
        "update",
        "typecodes",
        "nanpercentile",
        "diag_indices",
        "isin",
        "piecewise",
        "load_dotenv",
        "ftruncate",
        "is_multiprocess",
        "release",
        "core",
        "get_or_select_template",
        "issctype",
        "math",
        "nanvar",
        "range",
        "fromiter",
        "atleast_1d",
        "wsgi_app",
        "left_shift",
        "nancumsum",
        "import_string",
        "byte",
        "scandir",
        "parse",
        "access_route",
        "_debugmallocstats",
        "diag",
        "if_modified_since",
        "poly1d",
        "_putenv",
        "logical_or",
        "isreal",
        "log1p",
        "isneginf",
        "little_endian",
        "has_key",
        "_wrap_response",
        "removedirs",
        "asarray",
        "cookies",
        "append",
        "isnumeric",
        "isspace",
        "empty_like",
        "put_along_axis",
        "average",
        "get_converter",
        "render_template_string",
        "content_security_policy_report_only",
        "device_encoding",
        "compat",
        "url_charset",
        "arcsin",
        "maximum_sctype",
        "get_cookie_httponly",
        "overlay",
        "check_builtin",
        "isscalar",
        "mintypecode",
        "square",
        "from_pyfile",
        "greater",
        "allowed_methods",
        "get_cookie_secure",
        "shared",
        "short",
        "any",
        "issubclass",
        "globals",
        "_add_newdoc_ufunc",
        "jsonify",
        "ascii",
        "get_wsgi_headers",
        "object0",
        "nan",
        "htmlsafe_dumps",
        "warnings",
        "linked_to",
        "if_unmodified_since",
        "auto_pop",
        "rint",
        "path_hooks",
        "match",
        "fastCopyAndTranspose",
        "link",
        "ones",
        "tolist",
        "find_common_type",
        "cumprod",
        "datetime64",
        "inf",
        "less",
        "asarray_chkfinite",
        "intersect1d",
        "_checkClosed",
        "content_security_policy",
        "host_url",
        "_path_is_ancestor",
        "id",
        "raise_routing_exception",
        "count_nonzero",
        "refresh",
        "nditer",
        "corrcoef",
        "alen",
        "setdiff1d",
        "heaviside",
        "ulonglong",
        "conjugate",
        "broadcast",
        "fmax",
        "show_server_banner",
        "origin",
        "tril",
        "trunc",
        "compile_expression",
        "mean",
        "_git",
        "url_for",
        "format_float_scientific",
        "floor_divide",
        "format_parser",
        "write",
        "dsplit",
        "einsum",
        "zip",
        "fv",
        "set_handle_inheritable",
        "rjust",
        "setbufsize",
        "scheme",
        "delete_cookie",
        "url_map_class",
        "fromhex",
        "real",
        "pragma",
        "lstrip",
        "g",
        "gettrace",
        "get_rules",
        "statvfs_result",
        "is_endpoint_expecting",
        "input_stream",
        "expand_dims",
        "flexible",
        "provides_defaults_for",
        "charset",
        "pipe",
        "on_json_loading_failed",
        "repeat",
        "ipmt",
        "_unsetenv",
        "logical_xor",
        "copysign",
        "accept_languages",
        "iscomplexobj",
        "seterr",
        "copyto",
        "fsdecode",
        "str0",
        "dllhandle",
        "error",
        "ljust",
        "if_range",
        "ppmt",
        "logaddexp",
        "get_data",
        "modules",
        "exc_info",
        "mgrid",
        "altsep",
        "byte_bounds",
        "hello",
        "symmetric_difference_update",
        "random",
        "argmax",
        "add_template_test",
        "add",
        "from_json",
        "request_context",
        "mro",
        "run_command",
        "io",
        "len",
        "pycache_prefix",
        "_validate_key",
        "hash",
        "loads",
        "fromfunction",
        "hstack",
        "empty",
        "conj",
        "make_response",
        "digitize",
        "array_equal",
        "fmin",
        "datetime",
        "from_iterable",
        "uint8",
        "chararray",
        "tobytes",
        "unsignedinteger",
        "fget",
        "thread_info",
        "logical_and",
        "set_printoptions",
        "salt",
        "code_generator_class",
        "microseconds",
        "viewvalues",
        "reversed",
        "_execvpe",
        "hanning",
        "intersection",
        "host",
        "isposinf",
        "get_expiration_time",
        "hash_info",
        "_json",
        "hexversion",
        "urandom",
        "euler_gamma",
        "show_exception",
        "abs",
        "is_busday",
        "digest_method",
        "hasattr",
        "fset",
        "accept_ranges",
        "pow",
        "call_on_close",
        "rad2deg",
        "main",
        "real_if_close",
        "default_mimetype",
        "exit",
        "nbytes",
        "push",
        "call_factory",
        "disconnect",
        "create_jinja_loader",
        "set_inheritable",
        "genfromtxt",
        "oldnumeric",
        "inner",
        "shares_memory",
        "spacing",
        "take_along_axis",
        "transpose",
        "endpoint",
        "get_include",
        "void0",
        "_wrap_writer_for_text",
        "log",
        "get_load_dotenv",
        "fdopen",
        "breakpointhook",
        "unlink",
        "power",
        "logaddexp2",
        "htmlsafe_dump",
        "vstack",
        "union",
        "handle_user_exception",
        "issubdtype",
        "compile_templates",
        "is_secure",
        "execve",
        "should_set_cookie",
        "pop",
        "add_newdoc_ufunc",
        "_distributor_init",
        "half",
        "fsync",
        "fromkeys",
        "full",
        "object_",
        "geomspace",
        "quit",
        "find_app_by_string",
        "is_builtin",
        "access_control_request_method",
        "_is_range_request_processable",
        "set_string_function",
        "deprecate",
        "receivers",
        "errstate",
        "vsplit",
        "terminal_size",
        "config_class",
        "clear",
        "number",
        "flip",
        "readline",
        "ast",
        "i0",
        "intc",
        "fstat",
        "dict_storage_class",
        "kaiser",
        "http_date",
        "linspace",
        "fdel",
        "true_divide",
        "pad",
        "geterrobj",
        "abc",
        "sys",
        "concatenate",
        "handle_http_exception",
        "split",
        "remainder",
        "execfile",
        "set_asyncgen_hooks",
        "add_url_rule",
        "auto_find_instance_path",
        "get_cookie_path",
        "islower",
        "format_map",
        "polyadd",
        "polyfit",
        "open_session",
        "real-getter",
        "getitem",
        "resolution",
        "putenv",
        "char",
        "render_template",
        "last_modified",
        "_local",
        "asscalar",
        "encoding",
        "dstack",
        "unique",
        "get_printoptions",
        "clongdouble",
        "difference_update",
        "rot90",
        "data",
        "bin",
        "_NoValue",
        "temporarily_connected_to",
        "execvp",
        "fsencode",
        "raw_input",
        "roots",
        "logout",
        "savez",
        "base_exec_prefix",
        "next",
        "emath",
        "squeeze",
        "frompyfunc",
        "min_scalar_type",
        "supports_effective_ids",
        "isupper",
        "fromstring",
        "linalg",
        "getswitchinterval",
        "gravatar_url",
        "st",
        "polyval",
        "absolute",
        "isinf",
        "get_inheritable",
        "imag-getter",
        "cpu_count",
        "make_form_data_parser",
        "truncate",
        "array_str",
        "_globals",
        "long",
        "_cached_json",
        "format_datetime",
        "fromregex",
        "get_template",
        "after_request",
        "default_converters",
        "text_type",
        "base_repr",
        "tell",
        "multiply",
        "str_",
        "dumps",
        "fft",
        "nancumprod",
        "log2",
        "make_default_options_response",
        "polydiv",
        "select",
        "nanmax",
        "callable",
        "get_array_wrap",
        "process_response",
        "set_cookie",
        "shape",
        "alltrue",
        "get_cookie_samesite",
        "bytes_",
        "setxor1d",
        "click",
        "nextafter",
        "finfo",
        "endswith",
        "test",
        "savez_compressed",
        "arctan2",
        "implicit_sequence_conversion",
        "floating",
        "copyright",
        "traceback",
        "uname_result",
        "kron",
        "extend",
        "diff",
        "nanmean",
        "unpackbits",
        "prod",
        "stdout",
        "ord",
        "all",
        "double",
        "_load_template",
        "geterrcall",
        "iter_rules",
        "mimetype_params",
        "replace",
        "convolve",
        "ndfromtxt",
        "positive",
        "recfromcsv",
        "match_request",
        "center",
        "cumproduct",
        "lex",
        "locate_app",
        "_Environ",
        "_called_with_wrong_args",
        "hamming",
        "url_rule_class",
        "add_newdoc",
        "arange",
        "max_form_memory_size",
        "times",
        "content_language",
        "tensordot",
        "startswith",
        "parameter_storage_class",
        "int_info",
        "issuperset",
        "isdecimal",
        "prefix",
        "int16",
        "script_root",
        "polyint",
        "histogram",
        "compile",
        "access_control_request_headers",
        "isalnum",
        "top",
        "lexsort",
        "public_timeline",
        "startfile",
        "int32",
        "in1d",
        "hex",
        "request_init",
        "ndim",
        "get_json",
        "location",
        "save"
    ],
    "context_for_ast": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n            except:  \n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n    def __call__(self, environ, start_response):\n        return self.[API_POINT]\n",
    "context_for_data_flow": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n            except:  \n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n    def __call__(self, environ, start_response):\n        return self.unknown_api()\n",
    "context_for_type_inference": "import os\nimport sys\nimport numpy as np\nfrom io import StringIO as SI\nfrom datetime import timedelta\nfrom itertools import chain\nfrom threading import Lock\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequest\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import Map\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.wrappers import BaseResponse\nfrom . import cli\nfrom . import json\nfrom .config import Config\nfrom .config import ConfigAttribute\nfrom .ctx import _AppCtxGlobals\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _request_ctx_stack\nfrom .globals import g\nfrom .globals import request\nfrom .globals import session\nfrom .helpers import find_package\nfrom .helpers import get_debug_flag\nfrom .helpers import get_env\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import locked_cached_property\nfrom .helpers import url_for\nfrom .json import jsonify\nfrom .logging import create_logger\nfrom .scaffold import _endpoint_from_view_func\nfrom .scaffold import _sentinel\nfrom .scaffold import Scaffold\nfrom .scaffold import setupmethod\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import DispatchingJinjaLoader\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\nclass Flask(Scaffold):\n    request_class = Request\n    response_class = Response\n    jinja_environment = Environment\n    app_ctx_globals_class = _AppCtxGlobals\n    config_class = Config\n    testing = ConfigAttribute(\"TESTING\")\n    secret_key = ConfigAttribute(\"SECRET_KEY\")\n    session_cookie_name = ConfigAttribute(\"SESSION_COOKIE_NAME\")\n    permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n    send_file_max_age_default = ConfigAttribute(\n        \"SEND_FILE_MAX_AGE_DEFAULT\", get_converter=_make_timedelta\n    )\n    use_x_sendfile = ConfigAttribute(\"USE_X_SENDFILE\")\n    json_encoder = json.JSONEncoder\n    json_decoder = json.JSONDecoder\n    jinja_options = {\"extensions\": [\"jinja2.ext.autoescape\", \"jinja2.ext.with_\"]}\n    default_config = ImmutableDict(\n        {\n            \"ENV\": None,\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"JSON_AS_ASCII\": True,\n            \"JSON_SORT_KEYS\": True,\n            \"JSONIFY_PRETTYPRINT_REGULAR\": False,\n            \"JSONIFY_MIMETYPE\": \"application/json\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n    url_rule_class = Rule\n    url_map_class = Map\n    test_client_class = None\n    test_cli_runner_class = None\n    session_interface = SecureCookieSessionInterface()\n    import_name = None\n    template_folder = None\n    root_path = None\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder=\"static\",\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder=\"templates\",\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n        self.instance_path = instance_path\n        self.config = self.make_config(instance_relative_config)\n        self.url_build_error_handlers = []\n        self.before_first_request_funcs = []\n        self.teardown_appcontext_funcs = []\n        self.shell_context_processors = []\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.extensions = {}\n        self.url_map = self.url_map_class()\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=self.send_static_file,\n            )\n        self.cli.name = self.name\n    def _is_setup_finished(self):\n        return self.debug and self._got_first_request\n    @locked_cached_property\n    def name(self):\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n        return self.import_name\n    @property\n    def propagate_exceptions(self):\n        rv = self.config[\"PROPAGATE_EXCEPTIONS\"]\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n    @property\n    def preserve_context_on_exception(self):\n        rv = self.config[\"PRESERVE_CONTEXT_ON_EXCEPTION\"]\n        if rv is not None:\n            return rv\n        return self.debug\n    @locked_cached_property\n    def logger(self):\n        return create_logger(self)\n    @locked_cached_property\n    def jinja_env(self):\n        return self.create_jinja_environment()\n    @property\n    def got_first_request(self):\n        return self._got_first_request\n    def make_config(self, instance_relative=False):\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"ENV\"] = get_env()\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n    def auto_find_instance_path(self):\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n    def open_instance_resource(self, resource, mode=\"rb\"):\n        return open(os.path.join(self.instance_path, resource), mode)\n    @property\n    def templates_auto_reload(self):\n        rv = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n        return rv if rv is not None else self.debug\n    @templates_auto_reload.setter\n    def templates_auto_reload(self, value):\n        self.config[\"TEMPLATES_AUTO_RELOAD\"] = value\n    def create_jinja_environment(self):\n        options = dict(self.jinja_options)\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n        if \"auto_reload\" not in options:\n            options[\"auto_reload\"] = self.templates_auto_reload\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.filters[\"tojson\"] = json.tojson_filter\n        return rv\n    def create_global_jinja_loader(self):\n        return DispatchingJinjaLoader(self)\n    def select_jinja_autoescape(self, filename):\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\"))\n    def update_template_context(self, context):\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        context.update(orig_ctx)\n    def make_shell_context(self):\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n    env = ConfigAttribute(\"ENV\")\n    @property\n    def debug(self):\n        return self.config[\"DEBUG\"]\n    @debug.setter\n    def debug(self, value):\n        self.config[\"DEBUG\"] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n    def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n            if \"FLASK_ENV\" in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n        if debug is not None:\n            self.debug = bool(debug)\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n        cli.show_server_banner(self.env, self.debug, self.name, False)\n        from werkzeug.serving import run_simple\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            self._got_first_request = False\n    def test_client(self, use_cookies=True, **kwargs):\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n    def test_cli_runner(self, **kwargs):\n        cls = self.test_cli_runner_class\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n        return cls(self, **kwargs)\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        first_registration = False\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                \"A name collision occurred between blueprints\"\n                f\" {blueprint!r} and {self.blueprints[blueprint.name]!r}.\"\n                f\" Both share the same name {blueprint.name!r}.\"\n                f\" Blueprints that are created on the fly need unique\"\n                f\" names.\"\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n        blueprint.register(self, options, first_registration)\n    def iter_blueprints(self):\n        return iter(self._blueprint_order)\n    @setupmethod\n    def add_url_rule(\n        self,\n        rule,\n        endpoint=None,\n        view_func=None,\n        provide_automatic_options=None,\n        **options,\n    ):\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n        methods |= required_methods\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n    @setupmethod\n    def template_filter(self, name=None):\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        self.jinja_env.filters[name or f.__name__] = f\n    @setupmethod\n    def template_test(self, name=None):\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        self.jinja_env.tests[name or f.__name__] = f\n    @setupmethod\n    def template_global(self, name=None):\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        self.jinja_env.globals[name or f.__name__] = f\n    @setupmethod\n    def before_first_request(self, f):\n        self.before_first_request_funcs.append(f)\n        return f\n    @setupmethod\n    def teardown_appcontext(self, f):\n        self.teardown_appcontext_funcs.append(f)\n        return f\n    @setupmethod\n    def shell_context_processor(self, f):\n        self.shell_context_processors.append(f)\n        return f\n    def _find_error_handler(self, e):\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        for name, c in (\n            (request.blueprint, code),\n            (None, code),\n            (request.blueprint, None),\n            (None, None),\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n            if not handler_map:\n                continue\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n                if handler is not None:\n                    return handler\n    def handle_http_exception(self, e):\n        if e.code is None:\n            return e\n        if isinstance(e, RoutingException):\n            return e\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n    def trap_http_exception(self, e):\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n        return False\n    def handle_user_exception(self, e):\n        if isinstance(e, BadRequestKeyError):\n            if self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]:\n                e.show_exception = True\n                if e.args[0] not in e.get_description():\n                    e.description = f\"KeyError: {e.args[0]!r}\"\n            elif not hasattr(BadRequestKeyError, \"show_exception\"):\n                e.args = ()\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n        handler = self._find_error_handler(e)\n        if handler is None:\n            raise\n        return handler(e)\n    def handle_exception(self, e):\n        got_request_exception.send(self, exception=e)\n        if self.propagate_exceptions:\n            if exc_info[1] is e:\n                raise\n            raise e\n        self.log_exception(exc_info)\n        server_error = InternalServerError()\n        server_error.original_exception = e\n        handler = self._find_error_handler(server_error)\n        if handler is not None:\n            server_error = handler(server_error)\n        return self.finalize_request(server_error, from_error_handler=True)\n    def log_exception(self, exc_info):\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n    def raise_routing_exception(self, request):\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.method in (\"GET\", \"HEAD\", \"OPTIONS\")\n        ):\n            raise request.routing_exception\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n    def dispatch_request(self):\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        return self.view_functions[rule.endpoint](**req.view_args)\n    def full_dispatch_request(self):\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            if rv is None:\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n    def finalize_request(self, rv, from_error_handler=False):\n        try:\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n    def try_trigger_before_first_request_functions(self):\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n    def make_default_options_response(self):\n        adapter = _request_ctx_stack.top.url_adapter\n        methods = adapter.allowed_methods()\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n    def should_ignore_error(self, error):\n        return False\n    def make_response(self, rv):\n        status = headers = None\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n            if len_rv == 3:\n                rv, status, headers = rv\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)):\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            elif isinstance(rv, dict):\n                rv = jsonify(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, tuple, Response instance, or WSGI\"\n                        f\" callable, but it was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2])\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, tuple, Response instance, or WSGI\"\n                    f\" callable, but it was a {type(rv).__name__}.\"\n                )\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n        if headers:\n            rv.headers.update(headers)\n        return rv\n    def create_url_adapter(self, request):\n        if request is not None:\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n    def inject_url_defaults(self, endpoint, values):\n        funcs = self.url_default_functions.get(None, ())\n        if \".\" in endpoint:\n            bp = endpoint.rsplit(\".\", 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n    def handle_url_build_error(self, error, endpoint, values):\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n        if error is sys.exc_info()[1]:\n            raise\n        raise error\n    def preprocess_request(self):\n        bp = _request_ctx_stack.top.request.blueprint\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n    def do_teardown_request(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n    def do_teardown_appcontext(self, exc=_sentinel):\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n    def app_context(self):\n        return AppContext(self)\n    def request_context(self, environ):\n        return RequestContext(self, environ)\n    def test_request_context(self, *args, **kwargs):\n        from .testing import EnvironBuilder\n        builder = EnvironBuilder(self, *args, **kwargs)\n        try:\n        finally:\n            builder.close()\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n            except:  \n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n    def __call__(self, environ, start_response):\n        reveal_type(self)",
    "data_flow": "self-->unknown_api"
}